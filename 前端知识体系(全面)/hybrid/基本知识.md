#### hybrid是什么
hybrid，即混合，前端和客户端的混合开发，需要前端开发人员和客户端开发人员配合完成

#### 存在价值，为何会用hybrid

#### webview

#### file://协议
客户端使用file协议加载前端页面，这就意味着加载的是客户端本地的前端文件。这种方式相比于http协议会快很多。

#### hybrid实现流程


#### app发布之后，前端静态文件如何实时更新？
每次app打开，都去服务端获取最新的前端文件，然后缓存到客户端本地，覆盖掉旧版本的前端文件      
前端打包后文件，压缩成zip包，上传到服务器。客户端从服务器端获取压缩包，然后解压

流程：       
1.前端文件分版本，有版本号，如20201129      
2.将静态文件压缩成zip包，上传到服务端       
3.客户端每次启动，都去服务端检查版本号        
4.如果服务端版本号大于客户端版本号，就去下载最新的zip包       
5.下载完之后解压包，然后将现有文件覆盖       


#### 前端静态页面如何获取内容
前端页面不能再通过使用ajax等发请求获取数据，       
第一是因为跨域，webview使用file协议加载前端页面，请求使用http会有限制。       
第二是速度慢       

因此，请求都是通过客户端发起，然后JS通讯拿到数据，再渲染


#### JS和客户端通讯
1. JS和客户端通讯的基本形式，如下图      
![image](https://github.com/lizuncong/Front-End-Development-Notes/blob/master/resource/hybrid-01.jpg)
JS访问客户端能力，传递参数和回调函数       
客户端通过回调函数返回内容

2. schema协议简介和使用，前端和客户端通讯的约定      
![image](https://github.com/lizuncong/Front-End-Development-Notes/blob/master/resource/hybrid-02.jpg)

schema协议的使用： 
![image](https://github.com/lizuncong/Front-End-Development-Notes/blob/master/resource/hybrid-03.jpg)

如果需要传参数和callback，可以这么写：
![image](https://github.com/lizuncong/Front-End-Development-Notes/blob/master/resource/hybrid-04.jpg)



3. schema使用的封装      
![image](https://github.com/lizuncong/Front-End-Development-Notes/blob/master/resource/hybrid-05.jpg)
封装的代码可以参考 `invoke.js` ，内置到客户端        
客户端每次启动webview，都默认执行 invoke.js，本地加载，免去网络加载时间，更快。
本地加载，没有网络请求，黑客看不到schema协议，更安全。


#### hybrid技术原理
hybrid app的本质是在原生的app中，使用webview作为容器直接承载web页面。因此，***最核心的点就是Native端与H5端之间的双向通讯层***


##### 一、JavaScript通知Native，即JavaScript如何调用原生方法
基于webview的机制和开放的API，实现这个功能有三种常见的方案：      
1.API注入。原理其实Native获取JavaScript环境上下文，并直接在上面挂在对象或者方法，使js可以直接调用。        
2.webview中的prompt/console/alert拦截，通常使用prompt，因为这个方法在前端中使用频率低，比较不会出现冲突。       
3.webview URL Schema跳转拦截       

第2和第3种机制的原理是类似的，都是通过对WebView信息冒泡传递的拦截，从而达到通讯的，接下来主要从        
原理-定制协议-拦截协议-参数传递-回调机制       
5个方面详细阐述下第三种方案：URL拦截方案

实现原理：在WebView中发出的网络请求，客户端都能进行监听和捕获

协议的定制：需要制定一套 URL Schema 规则，通常我们的请求会带有对应的协议开头，例如常见的xxx.com或者file://1.jpg，代表着不同的含义。
这里可以将JavaScript和客户端通讯的请求定制为
> xxcommand://xxx?k1=v1&k2=v2

xxcommand只是一种规则，可以根据业务进行自定义定制。       
这里不要使用location.href发送，因为其自身机制有个问题就是同时并发多次请求会被合并成为一次，导致协议被忽略。因此这里会使用
创建iframe发送请求的方式。        
通常考虑到安全性，需要在客户端中设置域名白名单或者限制，避免公司内部业务协议被第三方直接调用


协议的拦截        
客户端可以通过API对webview发出的请求进行拦截。当解析到请求URL头为制定的协议时，便不发起对应的资源请求，而是解析参数，并进行相关功能或者方法的调用，
完成协议功能的映射。


协议回调         
由于协议的本质其实是发送请求，这属于一个异步的过程，因此我们便需要处理对应的回调机制。这里我们采用的方式是JS的事件系统，这里我们会用到 window.addEventListener 和 window.dispatchEvent这两个基础API；

1.发送协议时，通过协议的唯一标识注册自定义事件，并将回调绑定到对应的事件上。         
2.客户端完成对应的功能后，调用 Bridge 的dispatch API，直接携带 data 触发该协议的自定义事件        


参数传递方式            
由于 WebView 对 URL 会有长度的限制，因此常规的通过 search参数 进行传递的方式便具有一个问题，既 当需要传递的参数过长时，可能会导致被截断，例如传递base64或者传递大量数据时。

因此我们需要制定新的参数传递规则，我们使用的是函数调用的方式。这里的原理主要是基于:

Native 可以直接调用 JS 方法并直接获取函数的返回值。

我们只需要对每条协议标记一个唯一标识，并把参数存入参数池中，到时客户端再通过该唯一标识从参数池中获取对应的参数即可。
