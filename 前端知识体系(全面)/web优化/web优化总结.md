### web 优化总体方针

- 必备的基础理论知识
- 借助谷歌 lighthouse 工具具体问题具体分析
- 性能监控。毕竟性能优化不是一劳永逸的事情，随着版本迭代，性能必定会有波动

### 性能优化的目标

资源更小，速度更快的呈现在用户眼前。围绕着目标可以将性能优化分为以下 3 个方面

- 网络层面
- 渲染层面

### 网络层面

这个层面主要是涉及前端工程化方面。
目标：资源体积更小，加载更快

- 构建策略。基于构建工具，如 webpack。可分为以下两个维度：
  - 减少打包时间
    - 缩减 loader 范围。配置 include 或者 exclude 缩小 loader 的应用范围，避免不必要的编译。
    - loader 缓存。如 babel-loader 开启 cache
    - 定向搜索。配置 resolve.alias 提高文件的搜索速度
    - 提前构建。配置 DllPlugin 将第三方依赖提前打包。
    - 并行构建。如配置 thread loader 开启多线程打包
    - 可视结构。配置 BundleAnalyzer 分析打包文件的结构，找出导致体积过大的原因
  - 减少打包体积
    - 分割代码。配置 optimization.splitChunks 分割代码
    - Tree Shaking。Tree Shaking 只对 ESM 规范有效
    - 动态垫片。推荐使用动态垫片，动态垫片可根据浏览器 UserAgent 返回当前浏览器 Polyfill，其思路是根据浏览器的 UserAgent 从 browserlist 查找出当前浏览器哪些特性缺乏支持从而返回这些特性的 Polyfill。
      可参考 polyfill-library 和 polyfill-service 的源码。使用 html-webpack-tags-plugin 在打包时自动插入动态垫片。
    - 按需加载。原理动态 import()
    - 作用提升
    - 压缩资源。使用 uglifyjs 或者 terser-webpack-plugin 压缩 js 代码，使用 optimize-css-assets-webpack-plugin 压缩 css 代码。传输过程中开启 GZIP 压缩
- 图像策略。基于图像类型，JPG/PNG/SVG/WebP/Base64
  - 图像选型。了解所有图像类型的特点及其何种应用场景最合适
  - 图像压缩。在部署到生产环境前使用工具或脚本对其压缩处理
- 分发策略。基于内容分发网络（CDN）
  - 所有静态资源走 CDN
  - 静态资源与主页面置于不同域名下，绕开 HTTP 并发数量限制，但域名不宜过多，因为 DNS 寻址也是要时间的
- 缓存策略。基于浏览器缓存，如强缓存，协商缓存，本地数据缓存
- 网络请求。
  - 所有网络请求升级为 HTTP2，重用 TCP 连接
  - 合理使用域名分片。由于浏览器限制每个域名最多并行打开 6 个 TCP 连接，因此可以合理将资源部署在不同的域名下以提高并行性。当然弊端是每个新的域名都需要额外的 DNS 查询，
    每个额外的 TCP 连接都会消耗浏览器和服务器的资源。
  - 减少 DNS 查找。每个主机名解析都需要网络往返，这会对请求施加延迟并在查找过程中阻塞请求
  - 尽量减少 HTTP 重定向的数量。HTTP 重定向会带来高延迟开销——例如，单个重定向到不同的源会导致 DNS、TCP、TLS 和请求-响应往返，从而增加数百到数千毫秒的延迟。最佳重定向次数为零
  - 消除不必要的请求字节。尽可能少的使用 cookie
  - 资源合并以减少 HTTP 请求数

### 渲染层面

这个层面主要涉及日常搬砖过程中养成良好的编码习惯。

- CSS 策略。基于 CSS 规则。
  - 避免出现超过三层的嵌套规则
  - 避免为 ID 选择器添加多余选择器
  - 避免使用标签选择器代替类选择器
  - 避免使用通配选择器，只对目标节点声明规则
  - 值为 0 时不添加任何单位
  - 移除 CSS 空规则
  - 避免内联样式
- DOM 策略。基于 DOM 操作
  - 缓存 DOM 计算属性，比如使用本地变量缓存查找到的 dom 节点
  - 避免过多 DOM 操作
  - 使用 DOMFragment 缓存批量化 DOM 操作。
  - 尽量使用事件代理。避免将事件绑定到大量的 dom 节点上。
  - 如果是使用 Vue 框架，vue 框架内已经对渲染做了优化处理。如果使用的是 React，需要配合使用 react 提供的 memo 或者 shouldComponentUpdate 减少组件
    render。使用 useMemo，useCallBack 等缓存计算量大的数据
- 阻塞策略。基于脚本加载。比如可以设置脚本的 defer 或者 async，不阻塞 DOM 的构建
- 回流重绘策略。
  - 缓存 DOM 计算属性
  - 使用类合并样式，避免逐条改变样式
  - 使用 display 控制 DOM 显隐，将 DOM 离线化
  - 读写分离。避免又读又写。
- 异步更新策略。
  - 在异步任务中修改 DOM 时把其包装成微任务。
- 动画策略
  - 优先使用 CSS 动画，合理开启 GPU 加速，可通过 transform 开启 GPU 加速
  - 合理使用 requestAnimationFrame 代替 setTimeout
  - 高频操作使用节流或者防抖

### 性能评估

- 通过 Chrome DevTools LightHouse 获取页面性能指标报告
- 通过 Chrome DevTools Performance 获取页面性能瓶颈报告
- 通过 Performance API 获取页面各个阶段精确时间

### 单独介绍作用提升

分析模块间依赖关系，把打包好的模块合并到一个函数中，好处是减少函数声明和内存花销。作用提升首次出现于 rollup，是 rollup 的核心概念，后来在 webpack v3 里借鉴过来使用。
在未开启作用提升前，构建后的代码会存在大量函数闭包。由于模块依赖，通过 webpack 打包后会转换成 IIFE，大量函数闭包包裹代码会导致打包体积增大(模块越多越明显)。在运行代码时创建的函数作用域变多，从而导致更大的内存开销。
在开启作用提升后，构建后的代码会按照引入顺序放到一个函数作用域里，通过适当重命名某些变量以防止变量名冲突，从而减少函数声明和内存花销。
在 webpack 里只需将打包环境设置成生产环境就能让作用提升生效，或显式设置 concatenateModules。
