### 强缓存 和 协商缓存
- 缓存检测
    + 浏览器首先检测是否存在强缓存，有强缓存且未失效，则直接走强缓存。如果没有强缓存或者强缓存失效，则检测是否有协商缓存
    + 如果有协商缓存且未失效，则走协商缓存，如果没有协商缓存或者协商缓存失效，则获取最新的资源

- 缓存位置：Memory Cache 内存缓存。Disk Cache硬盘缓存。

- 打开网页或者刷新对于缓存的处理
    + 打开网页：查找disk cache中是否有匹配，如有则使用，如没有则发送网络请求
    + 普通刷新(F5)，因TAB没关闭，因此memory cache是可用的，会被优先使用，其次才是disk cache。
    + 强制刷新(Ctrl + F5)。浏览器不使用缓存，因此发送的请求头部均带有Cache-control:no-cache，服务器直接返回200和最新内容。

- 强缓存。 Expires/ Cache-control。浏览器对于强缓存的处理，根据第一次请求资源时返回的响应头来确定的。
    + Expires(HTTP/1.0字段)：缓存过期时间，用来指定资源到期的时间。
    + Cache-Control(HTTP/1.1)：cache-control：max-age=2592000第一次拿到资源后的2592000秒内(30天)，再次发送请求，读取缓存中的信息
    + 两者同时存在的话，Cache-Control优先级高于Expires
    + 对于不经常更新的资源，比如图片啥的，都可以使用强缓存。

- 协商缓存。Last-Modified / ETag。强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存。
    + Last-Modified(HTTP/1.0)。资源文件最后更新的时间
    + ETag(HTTP/1.1)。记录的是一个标识(也是根据资源文件更新生成的，每一次资源更新都会重新生成一个ETag)
    + 客户端携带获取的缓存标识(If-Modified-Since / If-None-Match)发送HTTP请求。
    + 服务器判断资源文件是否更新
      + 没更新，返回304，通知客户端读取缓存信息
      + 更新了，返回200及最新的资源信息，以及Last-Modified / ETag
    + 流程。第一次向服务器发送请求，假设此时没有强缓存和协商缓存。则浏览器直接向服务器发送请求，此时没有携带任何的缓存标识。
    服务器收到请求准备数据，并设置缓存标识。
    第二次发送请求，客户端会带上If-Modified-Since = Last-Modified的值。或者If-None-Match = ETag的值。

### 数据缓存
- localStorage
- redux
- vuex


### expires的问题
- 会受到客户端与服务器时间不一致的问题的影响


### Last-Modified的问题
- 一些文件也许周期性的更改,但是它的内容并不改变(仅仅改变的是修改时间),这个时候我们不希望客户端认为这个文件被修改了,而重新获取资源
- If-Modified-Since能检查到的粒度是秒级的。某些文件修改非常频繁,比如在秒一下的时间内进行修改(比如1s内修改了N次),,这种修改是无法判断的(或者说UNIX记录MTIME只能精确到秒);
- 某些服务器不能精确的得到文件的最后修改时间
