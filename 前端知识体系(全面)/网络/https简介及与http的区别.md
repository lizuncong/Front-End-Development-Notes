### HTTPS概述
HTTPS即是HTTP运行在安全的SSL/TLS协议上。基于HTTP协议，通过SSL或TLS提供加密处理数据，验证对方身份以及数据完整性保护。
浏览器和服务器在使用SSL建立连接时，需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持。

HTTPS的特点：
- 内容加密：采用混合加密技术，中间者无法直接查看明文内容
- 验证身份：通过证书认证客户端访问的是自己的服务器
- 保护数据完整性：防止传输的内容被中间人冒充或者篡改

### HTTPS与HTTP的区别
- 安全性。HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理，相对更安全。
- 资源耗费。HTTPS比HTTP要更耗费服务器资源
- 连接方式。HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443
- 性能。HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP。HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包
- 钱。HTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高

### HTTPS通信过程  [点我查看](https://www.runoob.com/w3cnote/http-vs-https.html)
- TLS 运行在可靠传输（TCP）之上，这意味着我们必须首先完成 TCP 三向握手，这需要一个完整的往返。
- 客户端通过URL访问服务器建立SSL连接
- 服务端收到客户端请求后，生成公钥和私钥，将网站支持的证书信息（证书中包含**公钥**）传送一份给客户端
- 客户端的TLS解析证书，验证公钥是否有效。如果无效，则提示证书有问题。如果有效，则生成一个**随机值Key**，然后用**证书**加密该**随机值Key**
- 客户端向服务器发送**加密的随机值Key**。以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。
- 服务端用**私钥**解密得到**随机值Key**。这样服务器就可以使用这个**随机值Key**对内容进行对称加密，并发送给客户端。
- 客户端使用**该随机值Key**解密得到内容。

### 了解一下HTTPS工作流程就好了
HTTPS工作流程一般如下：
- TCP三次同步握手
- 客户端验证服务器数字证书
- DH算法协商对称加密算法的密钥、hash算法的密钥
- SSL安全加密隧道协商完成
- 网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改



PS: 服务端发送给客户端的这套证书其实就是一对公钥和私钥，服务端只把公钥发给了客户端。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，
你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。


### 通信加密
网络中任何一个节点都可以截获浏览器和服务器的通信，获取信息，篡改内容，在网页里面插入广告，危害很大，因此需要对通信过程加密。

#### 第一版：直接简单加密
- 为了安全，每一次通信都要随机生成密钥。然后浏览器使用密钥加密数据。服务器使用这个密钥解密。这也是 **对称加密算法，也就是加密和解密使用的同一个秘钥。**
- 浏览器如何把密钥传给服务器？如果直接弄个字段告诉服务器密钥，那么在网络上的节点一样能拿得到密钥。因此这个方法不行。
- 浏览器和服务器私下约定，将密钥藏在数据的开头几个字节。
- 问题是，如果这种约定被传开了，比如公司内传到了公司外，那么也会有被解密的风险。因此这个方法不是很靠谱

#### 第二版：非对称加密
这种算法有两个秘钥，一个公开的叫公钥，一个私藏的叫私钥。最关键的是，公钥加密后只能用私钥解开，反过来也一样。

只要在正式的数据传输前，服务器把公钥告诉浏览器，浏览器用它加密数据，就算被别人抓包，他也解不开，因为只有拥有私钥的服务器才能解开。

这种方式只能单程加密，服务器能解密浏览器发的，但服务器发给浏览器的，浏览器却解不了，也不能让服务器用私钥加密，浏览器用公钥解密，因为公钥是公开的，谁收到都能解，不安全。

因此，浏览器也需要搞一对秘钥，通信之前双方都交换一下彼此的公钥，这样就可以双向加解密了


这种方式坏处就是：加解密太费时间了，导致浏览器渲染一个网页要花很久时间，卡的不行。同时服务器要服务很多浏览器，每一个都这么加解密，也不利于服务器性能。

#### 第三版：非对称与对称加密结合
浏览器和服务器的通信还是用原来的对称加密算法，这样快得多。但是一开始的时候可以用非对称加密算法来传输后面要用的秘钥，把两种算法的优势结合起来。

- 首先，服务器生成一对公钥私钥，并将公钥发送给浏览器
- 浏览器接收到公钥，随机生成一个key，这个key就是密钥，然后用服务器的公钥加密key并发送给服务器
- 服务器接收到浏览器加密的key，使用服务器的密钥解密得到key。此时服务器就拥有了浏览器的密钥。这个阶段就是非对称加密
- 接下来的通信过程中，客户端和服务器的通信都是用key加解密数据。这个阶段采用的就是对称加密

这个版本的问题在于，浏览器生成的密钥是一个随机数，而随机数并不是真正随机的，可能被预测出来，所以得提升这个秘钥的安全性

#### 第四版：密钥计算
一个随机数不够，那就多弄几个。一端容易被猜出来，那就两端一起生成！

浏览器和服务器各自生成一个随机数发给对方，服务器发送公钥给浏览器，浏览器再额外用服务器公钥加密传输一个随机数给服务器，这一来，双方都有3个随机数了，然后双方都用这三个随机数计算出真正的秘钥，这可比一个单纯的随机数要安全得多了。不过为了验证双方计算出来的秘钥是一样的，在正式数据传输前，需要先来测试一下

##### 整个过程中产生的三个随机数有什么作用呢？
- 浏览器随机生成一个随机数A，并在发起通信时发给服务器，这个过程是明文的
- 服务器收到浏览器的随机数A，生成一个自己的随机数B，并连同证书一起发送给浏览器，这个过程也是明文的
- 浏览器收到服务器的证书，验证证书是否有效。无效则提醒用户，有效则继续生成一个随机数`Pre-master secret`。并使用服务器的公钥加密后发送给服务器。同时发送一个校验值(也就是HASH值)，用来供服务器校验。

- 服务器使用私钥解密浏览器的报文得到 `Pre-master secret`，然后服务器同样发送一个校验值给浏览器，用来供浏览器校验。

- 三个随机数的作用：
    + 对于浏览器：当其生成了`Pre-master secret`之后，会结合原来的A、B随机数，用DH算法计算出一个master secret，紧接着根据这个master secret推导出hash secret和session secret。
    + 对于服务器：当其解密获得了Pre-master secret之后，会结合原来的A、B随机数，用DH算法计算出一个master secret，紧接着根据这个master secret推导出hash secret和session secret。
    + 在浏览器和服务端的master secret是依据三个随机数推导出来的，它是不会在网络上传输的，只有双方知道，不会有第三者知道。同时，浏览器推导出来的session secret和hash secret与服务端也是完全一样的
    + 那么现在双方如果开始使用对称算法加密来进行通讯，使用哪个作为共享的密钥呢？过程是这样子的：
    双方使用对称加密算法进行加密，用hash secret对HTTP报文做一次运算生成一个MAC，附在HTTP报文的后面，然后用session-secret加密所有数据（HTTP+MAC），然后发送。
    接收方则先用session-secret解密数据，然后得到HTTP+MAC，再用相同的算法计算出自己的MAC，如果两个MAC相等，证明数据没有被篡改。
    + MAC(Message Authentication Code)称为报文摘要，能够查知报文是否遭到篡改，从而保护报文的完整性。


#### 第五版：数字证书，服务器身份认证
攻击者冒充服务器跟浏览器通信，然后又冒充浏览器跟服务器通信，把浏览器的请求进行了转发，浏览器和服务器根本察觉不到，这就是中间人攻击。

因此还需要一个认证机制，浏览器得确认通信的对方是不是真的服务器。

服务器厂商推选了第三方机构做公证人（即数字证书中心CA），CA准备一对非对称加密的密钥，并公开了公钥，所有人都得把他的公钥记下来。

服务器得去CA先登记，把服务器的公钥、服务器的名字等等信息报上去，CA拿到这些信息后，计算一个Hash值，然后再用CA的**私钥**把Hash值进行加密，加密后的结果就是**数字签名**。

最后，CA把登记的信息和这个**数字签名**合在一起，封装了一个新的文件发给服务器，登记就完成了，而这个新的文件就是**数字证书**。

服务器拿到证书后，可要好生保管，因为通信的时候，服务器须要将证书发给浏览器验证。


浏览器验证证书：

浏览器拿到证书后，把证书里面的信息也计算一遍Hash，再用提前记录好的CA的公钥把证书里的数字签名进行解密，得到CA计算的Hash，两个一对比，就知道这证书是不是CA签发的，以及有没有被篡改过了！

只有验证成功才能继续后面的流程，要不然就是冒充的！

这一下总算解决了中间人冒充的问题，除非中间人偷到了CA的私钥，否则他是没办法伪造出一个证书来的。

##### 如果黑客拦截了服务器把证书发送给客户端，并对证书进行恶意修改，会出现什么情况？
- 第一种情况，假如黑客只是单纯的修改数字证书中的内容，那么由于数字签名的存在，客户端会很容易的判断出报文是否被篡改。

- 第二种情况，黑客不仅修改了数字证书的内容，并且把数字签名替换掉了，由于黑客不可能知道CA的私钥，于是在客户端用CA的公钥进行解密的时候，解密之后得不到正确的信息，也很容易判断出报文是否被修改。

- 第三种情况，黑客恶意的从相同的第三方CA申请了一个数字证书。由于这个CA是真实存在的，所以客户端是可以用CA的公钥进行解密，得到了黑客提供的数字证书中的公钥。但是，由于数字证书在申请的时候，会绑定一个域名，当客户端比如说浏览器，检测到这个数字证书中的域名和我们现在网页访问的域名不一致，便会发出警告，此时我们也能得知数字证书被替换了


### 第六版：信任链
如果只有一个根证书，显然是不够的，毕竟想要使用HTTPS的服务器那么多。因此，一级CA可以给二级CA签发证书，二级CA给三级CA签发等等。


原来只有一个一级CA的时候，大家直接保存他的公钥就行了。现在CA越来越多，我们没办法保存所有的CA的公钥了，就算能保存得下，但有新的CA出现的时候我们也做不到实时更新。


于是，大家约定，让所有的一级CA自己给自己签发一个证书，叫做**根证书**，**并安装在我们的操作系统中**。


以后在验证网站服务器的证书时，就得先去验证证书的签发者，然后再继续验证上一级签发者，直到验证最终的签发者是不是在根证书列表中。

只要最终的签发者在系统的根证书列表中，那这条链上签署的证书就都是受信任的，否则我们就会弹窗提醒用户：该网站的安全证书不受信任。


### 为什么非对称加密会比对称加密慢
这是因为对称加密主要的运算是位运算，速度非常快，如果使用硬件计算，速度会更快。以 AES 算法为例，如下图所示，其运算本质上来说就是位移和替换。


但是非对称加密计算一般都比较复杂，比如 RSA，它里面涉及到大数乘法、大数模等等运算。我们知道，幂运算的本质是乘法，乘法的基础单位是加法，也就是我们最常见的整数加。学过数字逻辑电路的同学想必都知道，在电路上实现“加法”比异或（XOR）要麻烦的多，况且后面还有一个模运算。因此非对称加密的速度自然而然是比不过对称加密的。当然，我想另外还有一个原因是，AES 中的许多中间计算过程是可以事先计算好的。加密数据时许多中间过程可以直接查表，而不需要实时地计算。