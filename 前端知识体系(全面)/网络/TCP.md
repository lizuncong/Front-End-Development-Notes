### TCP为什么需要三次握手
TCP协议被设计为一种面向连接的、可靠的、基于字节流的全双工传输层通信协议。

`“可靠”`意味着使用TCP协议传输数据时，如果 TCP 协议返回发送成功，那么数据一定已经成功的传输到了对端，为了保证数据的`“可靠”`传输，我们首先需要一个应答机制来确认对端已经收到了数据，而这就是我们熟悉的 ACK 机制。

`“流式”`则是一种使用上的抽象(即收发端不用关注底层的传输，只需将数据当作持续不断的字节流去发送和读取就好了)。`“流式”`的使用方式强依赖于数据的有序传输，为了这种使用上的抽象，我们需要一个机制来保证数据的有序，TCP 协议栈的设计则是给每个发送的字节标示其对应的 seq(实际应用中 seq 是一个范围，但其真实效果就是做到了每个字节都被有序标示)，接收端通过检视当前收到数据的 seq，并与自身记录的对端当前 seq 进行比对，以此确认数据的顺序。

`“全双工”`则意味着通信的一端的收发过程都是可靠且流式的，并且收和发是两个完全独立，互不干扰的两个行为。

综上，TCP三次握手的目的：
- 主要目的：收发端要同步对端的初始seq，以实现有序传输
- 同时双方都能明确自己和对方的收、发能力是正常的。

第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的

第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。

第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的

因此，最少需要三次，双方才能得出自己、对方的接收、发送能力都是正常的结论


### 三次握手
- 第一次握手：客户端尝试连接服务器，向服务器发送 syn 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认
- 第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个 SYN包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态
- 第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手


### 使用多个TCP连接
在 HTTP/1.x 中没有多路复用的情况下，浏览器可以单纯地将客户端上的所有 HTTP 请求排队，通过单个持久连接一个接一个地发送。在实践中，这种方式太慢了，因此可以选择
并行打开多个TCP连接。**大多数浏览器，每个主机最多打开6个TCP连接**

#### 使用多个TCP连接带来的成本
- 额外的内存缓冲区和 CPU 开销。CPU 和内存成本非常高
- 并行 TCP 流之间共享带宽的竞争
- 处理套接字集合的实现复杂度更高

### TCP和UDP的比较
- 可靠性。TCP是可靠的，UDP是不可靠的
- 交付。TCP是顺序交付的，如果有丢包则会一直阻塞。UDP是无序的，容忍丢包。
- 传输。TCP是面向字节的，UDP是面向消息的。
- 流量控制。TCP会流量控制，UDP不具备
- 拥塞控制。TCP具备拥塞控制，UDP不具备。


### TCP的设计问题
出于 TCP 设计的历史背景，当时的网络情况并没有现在这么复杂，整个网络的瓶颈在于带宽，所以整个 TCP 的字段设计非常精简，然而造成的效果就是将控制通道和数据通道被耦合的设计在了一起，在某些场景下就会形成问题。比如：
- seq 的二义性问题。设想这样的一个场景，发送端发送了一个 TCP 报文，由于通信的中间设备发生了阻塞，导致该报文被延迟转发了，发送端迟迟未收到 ACK，便重新发送了一个 TCP 报文，在新的 TCP 报文达到接收端时，被延迟转发的报文也达到了接收端，接收端只会响应一个 ACK。而客户端收到 ACK 时，并不清楚这个 ACK 是对延迟转发的报文的 ACK，还是新的报文的 ACK，带来的影响也就是 RTT 的估计会不准确，从而影响拥塞控制算法的行为，降低网络效率。

- 难用的 TCP keepalive。比如 TCP 连接中的另一方因为停电突然断网，我们并不知道连接断开，此时发送数据失败会进行重传，由于重传包的优先级要高于 keepalive 的数据包，因此 keepalive 的数据包无法发送出去。只有在长时间的重传失败之后我们才能判断此连接断开了。

- 队头阻塞问题。严格来说这并不算 TCP 自身的问题，因为 TCP 本身是一个面向链接的协议，它保证了一个链接上的数据可靠传输，也算完成了任务。然而随着互联网的普及，人们利用网络传输的数据越来越多，如果将所有数据都放在一个 TCP 链接上传输，其中某一个数据发生丢包，后面的数据的传输都会被 block 住，严重影响效率。当然，使用多个 TCP 链接传输数据是一种解决方案，但多个链接又会带来新的开销问题及链接管理问题。


### 为了安全引发的效率问题
HTTPS连接需要先经过三次TCP握手，然后才是TLS连接的建立。TLS 也是需要握手和交互的，虽然 TLS 协议经过多年的实践和演进，已经设计并落地了大量的优化手段(如 TLS1.3、会话复用、PSK、0-RTT 等技术)，但由于 TLS 和 TCP 的分层设计，一个安全数据通道的建立实际上仍是一个相对繁琐的流程。

从流程上来看，TCP 握手和 TLS 的握手似乎比较相似，有融合在一起的可能。的确有相关的文献探讨过在 SYN 报文里融合 ClientHello 的可行性，不过由于以下原因，这部分的探索也慢慢不了了之。
- TLS 本身也是基于有序传输设计的协议，融合在 TCP 中需要做大量的重新设计；
- 出于安全的考虑，TCP 的 SYN 报文被设计为不能携带数据，如果要携带 ClientHello，则需要对协议栈做大量改动，而由于 TCP 是一个内核协议栈，改动和迭代是一个痛苦且难以落地的过程；
- 新的协议难以和传统 TCP 兼容，大面积使用的可能性也很低。


### 参考链接
[https://mp.weixin.qq.com/s/ulrLwhzt327SJ3EDSMKwDg](https://mp.weixin.qq.com/s/ulrLwhzt327SJ3EDSMKwDg)